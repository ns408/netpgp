.\" $NetBSD: libtransit.3,v 1.4 2014/03/11 08:33:27 wiz Exp $
.\"
.\" Copyright (c) 2014 Alistair Crooks <agc@NetBSD.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 6, 2014
.Dt LIBTRANSIT 3
.Os
.Sh NAME
.Nm libtransit
.Nd data serialisation library
.Sh LIBRARY
.Lb libtransit
.Sh SYNOPSIS
.In transit.h
.Pp
.Ft int
.Fo transit_encode_number
.Fa "transit_t *transit" "uint64_t number"
.Fc
.Ft int
.Fo transit_encode_string
.Fa "transit_t *transit" "const char *string" "uint64_t length"
.Fc
.Ft int
.Fo transit_encode_special
.Fa "transit_t *transit" "uint8_t type"
.Fc
.Ft int
.Fo transit_decode
.Fa "transit_t *transit" "const char *in" "size_t length"
.Fc
.Ft int
.Fo transit_read_json
.Fa "transit_t *transit" "const char *in" "size_t length"
.Fc
.Ft int
.Fo transit_format_json
.Fa "transit_t *transit" "const char *out" "size_t bufsize"
.Fc
.Ft transit_t *
.Fo transit_new
.Fa "void"
.Fc
.Ft void
.Fo transit_free
.Fa "transit_t *transit"
.Fc
.Pp
Some accessor functions are also defined, for convenience when accessing
atoms, or fields of atoms.
.Ft transit_atom_t *
.Fo transit_atom
.Fa "transit_t *transit" "uint64_t atomindex"
.Fc
.Ft uint64_t
.Fo transit_atom_size
.Fa "transit_atom_t *atom"
.Fc
.Ft uint8_t
.Fo transit_atom_type
.Fa "transit_atom_t *atom"
.Fc
.Ft void *
.Fo transit_atom_ptr
.Fa "transit_atom_t *atom"
.Fc
.Ft uint8_t *
.Fo transit_encoded
.Fa "transit_t *transit"
.Fc
.Ft uint64_t
.Fo transit_size
.Fa "transit_t *transit"
.Fc
.Pp
Some dictionary and list access functions are also defined.
.Ft int
.Fo transit_field_by_index
.Fa "transit_t *transit" "uint32_t dictnum" "uint32_t fieldnum" "transit_atom_t *result"
.Fc
.Ft int
.Fo transit_field_by_name
.Fa "transit_t *transit" "uint32_t dictnum" "const char *fieldname" "transit_atom_t *result"
.Fc
.Sh DESCRIPTION
The
.Nm
library implements serialisation, and de\-serialisation
functionality.
Typically this can be used to transmit data in an endian\-neutral,
and encoding-neutral, manner.
It is designed to be used where (structured) data needs to be exchanged
in an efficient manner.
.Nm
can also convert from JSON to its
own internal format.
.Pp
The on\-the\-wire
.Nm
format is designed to be concise, and simple.
Four types of data representation are defined:
a number, a string, a list of items, and a dictionary of items.
Numbers are encoded with only the necessary sequence of characters
to express them, rather than taking 4 bytes,
or multiple ASCII-encoded
bytes, as in JSON.
Similarly, there is no ASCII\-encoding of strings, or escaped
characters.
Instead, the string length is encoded at the start of the string,
and the bytes following the length form the string itself.
No escaping is necessary or implemented.
The full protocol, with examples, is explained in more detail
later in this document.
.Pp
Lists, and dictionaries, are defined in terms of the other data elements;
no length is encoded at the start, and an explicit
.Dq end of structure
marker is placed in the encoded data stream.
.Pp
To encode a stream from some structured data, the
transit data is built using the
.Fn transit_encode_number ,
.Fn transit_encode_string ,
and
.Fn transit_encode_special ,
functions.
When encoding a string,
the special value
.Dv TRANSIT_STRLEN
can be used if the input is NUL-terminated,
to derive the number of bytes from the string input.
This is useful in the case where a string is dynamically generated.
.Pp
Lists and dictionaries are introduced, and completed,
by using the
.Fn transit_encode_special
functions.
Encoded JSON can be converted into the transit protocol using the
.Fn transit_read_json
function, whilst
the data can be formatted into output as JSON using the
.Fn transit_format_json
function.
.Pp
To decode serialised input, possibly at the other end of a connection,
the
.Fn transit_decode
function is used to create the structure, and that can
then be manipulated using some of the desired macros
and accessor functions.
.Pp
It should be noted that if, for any reason, the input is not
well\-formed, the error will cause decoding to complete immediately
with an error code.
It is not the job of the protocol to recover from errors in transmission;
rather, some form of data resilience
such as
.Xr librs 3
and
.Xr libcirca 3
should be employed if this
is considered to be a requirement.
.Pp
If a dynamically allocated structure is needed, the
.Fn transit_new
function is used.
When the structure is no longer needed,
.Fn transit_free
can be used to free up all resources allocated to the
structure.
.Sh PROTOCOL
The
.Dq transit
protocol is made up of a very few components, all of which are aimed to produce
a dynamic environment for people who wish to use the protocol, as well as
keeping communications and data usage as compact and efficient as possible.
A
.Dq type
byte is the first thing on the wire, and directs the protocol decoder to
recognise the information which directly follows.
There are two atomic data types, a number and a string of bytes.
Numbers are encoded in such a way as to keep the number of characters used, by
using the 8th bit of each byte to denote whether this is the last byte or not.
By doing this, the number is encoded in as few bytes as possible.
.Pp
The string of bytes is preceded by its length in bytes, encoded
as a
.Dq number .
When encoding strings,
the byte string does not need to be NUL-terminated.
Neither do any characters need to be escaped.
.Pp
The two atomic types are used, as in JSON, to construct structured data.
At the present time, two types of structured data are provided,
a list or array, and a dictionary.
These two structures are the same as JSON.
.Pp
For example, let us assume the encoder wants to represent the abstract array
.Dq [1,["two",3],["four",5]]
The encoding would look like:
.Bd -literal -offset indent
03		      -- List follows
    01                -- Number follows
        01            -- 1
    03                -- List follows
        02            -- String follows
            03        -- 3 bytes in string
            74776f    -- "two"
        01            -- Number follows
            03        -- 3
        05            -- End of list (inner list)
    03                -- List follows
        02            -- String follows
            04        -- 4 bytes in string
            666f7572  -- "four"
        01            -- Number follows
            05        -- 5
        05            -- End of list (inner list)
    05                -- End of list (outer list)
.Ed
.Pp
as can be seen from the following dump of the JSON conversion output
.Pp
.Bd -literal -offset indent
% transit -j '[1,["two",3],["four",5]]' | hexdump -C
00000000  03 01 01 03 02 03 74 77  6f 01 03 05 03 02 04 66  |......two......f|
00000010  6f 75 72 01 05 05 05                              |our....|
00000017
% transit -j '[1,["two",3],["four",5]]' | transit -d
list
        number  1
        list
                string  two
                number  3
        list
                string  four
                number  5
%
.Ed
.Sh EXAMPLES
The following code fragment adds strings from an array into
a list in the internal structure, and then encodes the resulting structure.
.Bd -literal -offset indent
transit_t	t;
memset(\*[Am]t, 0x0, sizeof(t));
transit_encode_special(\*[Am]t, TRANSIT_LIST);
for (i = optind ; i < argc ; i++) {
	transit_encode_string(\*[Am]t, argv[i], strlen(argv[i]));
}
transit_encode_special(\*[Am]t, TRANSIT_END);
fwrite(TRANSIT_ENCODED(\*[Am]t), 1, TRANSIT_SIZE(\*[Am]t), stdout);
.Ed
.Pp
and the corresponding output is shown below
.Bd -literal -offset indent
% transit one two three 4 five | hexdump -C
00000000  03 02 03 6f 6e 65 02 03  74 77 6f 02 05 74 68 72  |...one..two..thr|
00000010  65 65 02 01 34 02 04 66  69 76 65 05              |ee..4..five.|
0000001c
% transit one two three 4 five | transit -d
list
        string  one
        string  two
        string  three
        string  4
        string  five
%
.Ed
.Sh SEE ALSO
.Xr transit 1 ,
.Xr libcirca 3 ,
.Xr librs 3
.Sh HISTORY
The
.Nm
library first appeared in
.Nx 7.0 .
.Sh AUTHORS
.An Alistair Crooks Aq Mt agc@NetBSD.org
